<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - map controls</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #ccc;
			color: #000;
		}

		a {
			color: #f00;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - map controls
	</div>

	<script id="fragmentShaderColor" type="x-shader/x-fragment">

			varying float vAmount;

			void main() 
			{	
								
				vec4 snow  = smoothstep(0.90, 0.99, vAmount) * vec4(1.0, 1.0, 1.0, 0.0); 
				vec4 rock = ( smoothstep(0.80, 0.95, vAmount) - smoothstep(0.90, 0.96, vAmount) ) * vec4(0.7, 0.5, 0.0, 0.0); 
				vec4 plateu  =  (smoothstep(0.70, 0.90, vAmount)-smoothstep(0.80, 0.90, vAmount)) * vec4(0.4, 0.8, 0.4, 0.0); 
				vec4 forest  =  (smoothstep(0.60, 0.80, vAmount)-smoothstep(0.70, 0.80, vAmount)) * vec4(0.1, 0.90, 0.1, 0.0); 
				vec4 farms  =  (smoothstep(0.50, 0.70, vAmount)-smoothstep(0.60, 0.70, vAmount)) * vec4(0.6, 0.9, 0.0, 0.0); 
				vec4 sand = (smoothstep(0.40, 0.60, vAmount)- smoothstep(0.50, 0.60, vAmount) ) * vec4(0.9, 0.9, 0.1, 0.0);
				
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) + sand + farms + forest + plateu + snow + rock;
			}

		</script>

	<script id="fragmentShaderTexture" type="x-shader/x-fragment">

			uniform sampler2D satTexture;
			
			varying vec2 vUV;

			void main() 
			{	
				gl_FragColor = texture2D( satTexture, vUV );
			}

		</script>

	<script id="fragmentShaderTextureBorder" type="x-shader/x-fragment">

			uniform sampler2D satTexture;
			
			varying vec2 vUV;

			void main() 
			{	
				gl_FragColor = texture2D( satTexture, vUV );
				
				// float mixAmount = 1.0-step(0.99, vUV.x);
				// gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), mixAmount);
				
				vec2 c = abs( vUV - vec2( 0.5 ) ) * 2.0;
				float f = 1.0 - step( c.x, 0.99 ) * step( c.y, 0.99 );
				gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), f);
			}

		</script>

	<script id="vertexShader" type="x-shader/x-vertex">

			uniform sampler2D bumpTexture;
			uniform float bumpScale;

			varying float vAmount;
			varying vec2 vUV;

			void main() 
			{ 
				vUV = uv;

				vec4 bumpData = texture2D( bumpTexture, uv );
				
				vAmount = bumpData.r; // assuming map is grayscale it doesn't matter if you use r, g, or b.
				
				// move the position along the normal
				vec3 newPosition = position + normal * bumpScale * vAmount;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}

		</script>

	<script type="module">

		import * as THREE from './threejs/three.module.js';

		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { MapControls } from './jsm/controls/RotatedSlideOrbitControls.js';
		import { Sky } from './jsm/objects/Sky.js';
		import { Water } from './jsm/objects/Water.js';

		import Stats from './jsm/libs/stats.module.js';

		let camera, controls, scene, renderer;
		let uniforms;
		let water, oldWater, oldWaterTex, noBumpTex, sun;
		let uniformsTemplate;
		const frustum = new THREE.Frustum();
		let selectedTile = null;

		let rootTile;
		let visibleTiles = [];
		const tileGeometries = new Map();
		const tileWireGeometries = new Map();
		const RENDER_MODE_2D = 0;
		const RENDER_MODE_3D_SAT = 1;
		const RENDER_MODE_3D_COL = 2;
		const RENDER_MODE_3D_SAT_B = 3;

		let lastPost = new THREE.Vector3();
		let ground = new THREE.Group();

		let MAX_DIST = 4_000_000;
		let MIN_DIST = 40;
		let BUMP_SCALE = 100.0;
		let MAX_ZOOM = 13;
		let ZOOM_COLOR_MAP = { 0: '#ff0000', 1: '#ff8000', 2: '#ffff00', 3: '#80ff00', 4: '#00ff00', 5: '#00ff80', 6: '#00ffff', 7: '#0080ff', 8: '#0000ff', 9: '#8000ff', 10: '#ff00ff', 11: '#ff0080', 12: '#ffbf00', 13: '#bfff00', 14: '#40ff00', 15: '#00ff40', 16: '00ffbf', 17: '#00bfff', 18: '	#0040ff', 19: '#4000ff', 20: '#bf00ff', 21: '#ff00bf', 22: '#ff0040', 23: 'black' };
		let PLANE_Z = -29.5;
		var options = {
			zoomIn: function () {
				controls.scale = 0.95;
			},
			zoomOut: function () {
				controls.scale = 1.05;
			},
			go2d: function () {
				camera.position.x = controls.target.x;
				camera.position.y = controls.target.y;
				renderModeChanged();
			},
			render2d: true,
			renderTexture: true,
			renderMode: RENDER_MODE_2D,
			zoom: 0
		};

		let SCENE_WIDTH = 2_000_000;
		let HALF_SCENE_WIDTH = SCENE_WIDTH / 2;
		let SCENE_HEIGHT = 2_000_000;
		let HALF_SCENE_HEIGHT = SCENE_HEIGHT / 2;

		const stats = Stats()
		document.body.appendChild(stats.dom);

		const gui = new GUI();
		const raycaster = new THREE.Raycaster();

		const parameters = {
			oldWater: true,
			inclination: 0.22,
			azimuth: 0.1
		};

		class ATile {
			constructor(left, bottom, width, height, zoom) {
				this.left = left;
				this.bottom = bottom;

				this.centerX = left + width / 2;
				this.centerY = bottom + height / 2;

				this.width = width;
				this.height = height;

				this.box = new THREE.Box3();
				this.box.setFromCenterAndSize(new THREE.Vector3(this.centerX, this.centerY, PLANE_Z), new THREE.Vector3(width, height, 5));

				this.zoom = zoom;

				this.plane = null;
				this.showBorder = false;

				this.children = null;
				this.renderMode = RENDER_MODE_2D;

				const nTiles = zoomToNTiles(this.zoom);
				const tileWidth = SCENE_WIDTH / nTiles;
				const tileHeight = SCENE_HEIGHT / nTiles;


				this.uOffset = Math.floor((this.left + HALF_SCENE_WIDTH) / tileWidth);
				this.vOffset = Math.floor((this.bottom + HALF_SCENE_HEIGHT) / tileHeight);

			}

			show() {
				if (options.renderMode != this.renderMode && this.plane != null) {
					this.plane.material = buildCustomMaterial(this.uOffset, this.vOffset, this.zoom, this.showBorder);
					this.renderMode = options.renderMode;
				}

				if (this.plane == null) {
					this.plane = newTilePlane(this);
					ground.add(this.plane);
				}

				this.plane.frustumCulled = false;
				this.plane.visible = true;
			}

			hide() {
				this.plane.frustumCulled = true;
				this.plane.visible = false;
			}

			split() {
				if (this.zoom == MAX_ZOOM) {
					this.children = [];
					return;
				}

				const halfWidth = this.width / 2;
				const halfHeight = this.height / 2;

				const tile00 = new ATile(this.left/*		*/, this.bottom/*		  */, halfWidth, halfHeight, this.zoom + 1);
				const tile01 = new ATile(this.left + halfWidth, this.bottom/*		  */, halfWidth, halfHeight, this.zoom + 1);
				const tile10 = new ATile(this.left/*		*/, this.bottom + halfHeight, halfWidth, halfHeight, this.zoom + 1);
				const tile11 = new ATile(this.left + halfWidth, this.bottom + halfHeight, halfWidth, halfHeight, this.zoom + 1);

				this.children = [tile00, tile01, tile10, tile11];
			}
		}

		init();
		//render(); // remove when using next line for animation loop (requestAnimationFrame)
		animate();

		function init() {
			const initStartDate = new Date();

			buildSceneCamera();
			buildControls();
			buildWater();
			//buildSky();

			uniformsTemplate = buildTemplateUniforms();

			// lights
			const dirLight1 = new THREE.DirectionalLight(0xffffff);
			dirLight1.position.set(1, 1, 1);
			//scene.add( dirLight1 );

			const dirLight2 = new THREE.DirectionalLight(0x002288);
			dirLight2.position.set(- 1, - 1, - 1);
			//scene.add( dirLight2 );

			const ambientLight = new THREE.AmbientLight(0x222222);
			//scene.add( ambientLight );

			//
			buildMap();

			window.addEventListener('resize', onWindowResize);
			document.addEventListener('pointerdown', onDocumentMouseDown, false);

			buildGui();

			console.log("Init completed in %s millis", new Date().getTime() - initStartDate);
		}

		function buildSceneCamera() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xcccccc);
			//scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 10, MAX_DIST + 1);
			camera.up = new THREE.Vector3(0, 0, 1);
		}

		function buildControls() {
			controls = new MapControls(camera, renderer.domElement, MAX_ZOOM);

			controls.enableDamping = false;
			controls.dampingFactor = 0.05;

			controls.screenSpacePanning = false;

			controls.minDistance = MIN_DIST;
			controls.maxDistance = MAX_DIST;

			//controls.maxPolarAngle = Math.PI / 2;

			camera.position.set(0, 0, MAX_DIST);
			controls.target.copy(new THREE.Vector3(camera.position.x, camera.position.y, 0));

			controls.zoomSpeed = 13.5;
		}

		function buildSky() {
			sun = new THREE.Vector3();

			const sky = new Sky();

			sky.scale.setScalar(300000);
			scene.add(sky);

			const skyUniforms = sky.material.uniforms;
			skyUniforms['turbidity'].value = 10;
			skyUniforms['rayleigh'].value = 2;
			skyUniforms['mieCoefficient'].value = 0.005;
			skyUniforms['mieDirectionalG'].value = 0.8;
			skyUniforms['up'].value = new THREE.Vector3(0, 0, 1);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);

			function updateSun() {

				const theta = Math.PI * (parameters.inclination - 0.5);
				const phi = 2 * Math.PI * (parameters.azimuth - 0.5);

				sun.x = Math.cos(phi);
				sun.y = Math.sin(phi) * Math.sin(theta);
				sun.z = Math.sin(phi) * Math.cos(theta);

				sky.material.uniforms['sunPosition'].value.copy(sun);
				water.material.uniforms['sunDirection'].value.copy(sun).normalize();

				scene.environment = pmremGenerator.fromScene(sky).texture;

			}

			updateSun();

			const folderSky = gui.addFolder('Sky');
			folderSky.add(parameters, 'inclination', 0, 0.5, 0.0001).onChange(updateSun);
			folderSky.add(parameters, 'azimuth', 0, 1, 0.0001).onChange(updateSun);
			// folderSky.open();
		}

		function buildWater() {
			const waterGeometry = new THREE.PlaneGeometry(SCENE_WIDTH, SCENE_HEIGHT, 1000, 600);

			water = new Water(
				waterGeometry,
				{
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: new THREE.TextureLoader().load('images/waternormals.jpg', function (texture) {

						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

					}),
					alpha: 0.90,
					sunDirection: new THREE.Vector3(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 3.7,
					fog: scene.fog !== undefined
				}
			);
			water.material.transparent = true;
			//water.rotation.x = - Math.PI / 2;
			water.visible = !parameters.oldWater;
			scene.add(water);

			var oldWaterGeo = new THREE.PlaneGeometry(SCENE_WIDTH, SCENE_HEIGHT, 1, 1);
			oldWaterTex = new THREE.TextureLoader().load('images/water512.jpg');
			noBumpTex = new THREE.TextureLoader().load('images/black.jpg');

			oldWaterTex.wrapS = oldWaterTex.wrapT = THREE.RepeatWrapping;
			oldWaterTex.repeat.set(5, 5);

			var oldWaterMat = new THREE.MeshBasicMaterial({ map: oldWaterTex, transparent: true, opacity: 0.4 });
			oldWater = new THREE.Mesh(oldWaterGeo, oldWaterMat);
			// oldWater.rotation.x = -Math.PI / 2;

			///oldWater.position.y = 0;
			oldWater.position.z = 20.1;
			oldWater.renderOrder = 20;
			oldWater.visible = parameters.oldWater;

			scene.add(oldWater);

			function toggleWater() {

				if (parameters.oldWater) {
					//water.visible = false;
					oldWater.visible = true;
				} else {
					//water.visible = true;
					oldWater.visible = false;
				}
			}

			const waterUniforms = water.material.uniforms;

			const folderWater = gui.addFolder('Water');
			folderWater.add(parameters, 'oldWater').name('Toggle water').onChange(toggleWater);
			folderWater.add(waterUniforms.distortionScale, 'value', 0, 8, 0.1).name('distortionScale');
			folderWater.add(waterUniforms.size, 'value', 0.1, 10, 0.1).name('size');
			folderWater.add(waterUniforms.alpha, 'value', 0.85, 1, .01).name('alpha');
			// folderWater.open();
		}

		function buildGui() {
			gui.add(controls, 'screenSpacePanning');
			gui.add(controls.pSphere, 'radius', 0, MAX_DIST).onChange(render).listen();
			gui.add(camera.position, 'y', 0, MAX_DIST, 1000).onChange(render).listen();
			gui.add(options, 'render2d').listen();
			gui.add(options, 'renderTexture').onChange(renderModeChanged);
			gui.add(controls, 'zoomLevel').listen();
			gui.add(options, 'zoom').listen();
			gui.add(options, 'zoomIn');
			gui.add(options, 'zoomOut');
			gui.add(options, 'go2d');
			gui.add(oldWater.position, 'z');
		}

		function renderModeChanged() {
			updateRenderMode();
			forceRenderMap();
		}

		function forceRenderMap() {
			lastPost = new THREE.Vector3();
		}

		function updateRenderMode() {
			options.renderMode = options.render2d ? RENDER_MODE_2D : (options.renderTexture ? RENDER_MODE_3D_SAT : RENDER_MODE_3D_COL);
		}

		function buildTemplateUniforms() {

			var uniforms = {
				bumpScale: { type: "f", value: BUMP_SCALE },
			};

			return uniforms;
		}

		function buildCustomMaterial(x, y, z, border = false) {

			//var bumpTexture = new THREE.TextureLoader().load(`images/demTiles13/${z}/${x}/${y}.png`);

			// var satTexture = new THREE.TextureLoader().load(`images/eastAnatoliaSat/${z}/${x}/${y}.png`);
			// bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping;

			// new THREE.TextureLoader().load(`images/demTiles13/${z}/${x}/${y}.png`, 
			// function ( bTexture ) {
			// uniforms['bumpTexture'] = { type: "t", value: bTexture };						
			// }
			// );

			if (options.render2d) {
				return build2dMat(x, y, z);
			}
			else {
				return build2dMat(x, y, z);
				//return build3dMat(x, y, z, border=false);

			}

		}

		function build2dMat(x, y, z) {
			const mat2d = new THREE.MeshBasicMaterial({
				map: oldWaterTex,
			});

			var satTexture = new THREE.TextureLoader().load(`images/eastAnatoliaSat/${z}/${x}/${y}.png`,
				function (texture) {
					mat2d.map = texture;
					forceRenderMap();
				}
			);

			return mat2d;
		}

		function build3dMat(x, y, z, border = false) {
			var uniforms = Object.assign({}, uniformsTemplate);
			uniforms['satTexture'] = { type: "t", value: oldWaterTex };
			uniforms['borderAmount'] = { type: "f", value: 1.0 };

			const fragmentShaderName = options.renderTexture ? (border ? 'fragmentShaderTextureBorder' : 'fragmentShaderTexture') : 'fragmentShaderColor';

			new THREE.TextureLoader().load(`images/eastAnatoliaSat/${z}/${x}/${y}.png`,
				function (texture) {
					uniforms['satTexture'] = { type: "t", value: texture };
					forceRenderMap();
				}
			);

			return new THREE.ShaderMaterial(
				{
					uniforms: uniforms,
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById(fragmentShaderName).textContent
				}
			);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);

			controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
			render();

			stats.update();
		}

		function render() {
			const time = performance.now() * 0.001;
			water.material.uniforms['time'].value += 1.0 / 60.0;
			if (Math.abs(lastPost.x - camera.position.x) < 0.001 && Math.abs(lastPost.y - camera.position.y) < 0.001 && Math.abs(lastPost.z - camera.position.z) < 0.001) return;
			renderMap();

			renderer.render(scene, camera);
		}


		function renderMap() {
			//if (Math.abs(lastPost.x-camera.position.x)<0.001 && Math.abs(lastPost.y-camera.position.y)<0.001 && Math.abs(lastPost.z-camera.position.z)<0.001) return;

			visibleTiles.forEach(tile => tile.hide());

			//console.log("1-renderMap start ****");

			const render2dOld = options.render2d;
			options.render2d = Math.abs(camera.position.z - controls.target.z - camera.position.distanceTo(controls.target)) < 0.001;

			if (options.render2d != render2dOld) {
				updateRenderMode();
			}

			visibleTiles = [];
			options.zoom = distanceToZoom(camera.position.distanceTo(controls.target));

			const matrix = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);//.multiply(new THREE.Matrix4().makeTranslation(5000,0,100));
			frustum.setFromProjectionMatrix(matrix);

			if (options.render2d) {
				findVisible2D(rootTile, controls.zoomLevel, 0, frustum, visibleTiles);
			} else {
				findVisible(rootTile, controls.zoomLevel, 0, frustum, visibleTiles);
			}


			visibleTiles.forEach(tile => tile.show());

			console.log("%s tiles (13 %s, 12 %s, 11 %s, 10 %s) are visible", visibleTiles.length, visibleTiles.filter(tile => tile.zoom == 13).length, visibleTiles.filter(tile => tile.zoom == 12).length, visibleTiles.filter(tile => tile.zoom == 11).length, visibleTiles.filter(tile => tile.zoom == 10).length);

			lastPost = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
		}

		function buildMap() {
			// ground.rotation.x = -Math.PI / 2;
			scene.add(ground);

			rootTile = new ATile(-HALF_SCENE_WIDTH, -HALF_SCENE_HEIGHT, SCENE_WIDTH, SCENE_HEIGHT, 0);

			for (var zoom in ZOOM_COLOR_MAP) {
				zoom = parseInt(zoom);
				const nTiles = zoomToNTiles(zoom);

				tileGeometries.set(zoom, new THREE.PlaneGeometry(SCENE_WIDTH / nTiles, SCENE_HEIGHT / nTiles, 255, 255));
				tileWireGeometries.set(zoom, new THREE.PlaneGeometry(SCENE_WIDTH / nTiles, SCENE_HEIGHT / nTiles));
			}

		}

		function findVisible(tile, zoom, level, viewRect, visibleTiles) {
			//if (selectedTile == tile) {
			//	console.log("Found selected tile");
			//}

			//if (tile.children == null) {
			//	tile.split();
			//}

			//for (var aatile of tile.children) {
			//	if (selectedTile == aatile) {
			//		console.log("Found selected tile");
			//	}
			//}

			const box = new THREE.Box3().copy(tile.box);

			if (tile.plane != null)
				box.applyMatrix4(tile.plane.matrixWorld);//.applyMatrix4(ground.matrixWorld);
			else {
				box.min.z = -150;
				box.max.z = 150;
			}

			if (!viewRect.intersectsBox(box)) {
				return;
			}

			if (tile.children == null) {
				tile.split();
			}

			if (tile.children.length == 0 || level >= zoom || Math.abs(tile.centerX - controls.target.x) / tile.width > 2 || Math.abs(tile.centerY - controls.target.y) / tile.height > 2) {
				visibleTiles.push(tile);
				// console.log("Tile level past zoom Tile=%o ViewRecf=%o zoom=%s level=%s", tile, viewRect, zoom, level);
			}
			else if (level == zoom) {
				visibleTiles.push(tile);
			}
			else {
				for (var i = 0; i < 4; i++) {
					const child = tile.children[i];
					//findVisible(child, zoom, level + 1, viewRect, visibleTiles);
					//findVisible(child, distanceToZoom(camera.position.distanceTo(new THREE.Vector3(tile.centerX, tile.centerY, controls.target.z).add(controls.target).divideScalar(2.0))), level + 1, viewRect, visibleTiles);

					findVisible(child, zoom, level + 1, viewRect, visibleTiles);

				}
			}

		}

		function findVisible2D(tile, zoom, level, viewRect, visibleTiles) {
			const box = new THREE.Box3().copy(tile.box);

			if (tile.plane != null)
				box.applyMatrix4(tile.plane.matrixWorld).applyMatrix4(ground.matrixWorld);

			if (!viewRect.intersectsBox(box)) {
				return;
			}

			if (tile.children == null) {
				tile.split();
			}

			if (tile.children.length == 0 || level >= zoom) {
				visibleTiles.push(tile);
				// console.log("Tile level past zoom Tile=%o ViewRecf=%o zoom=%s level=%s", tile, viewRect, zoom, level);
			} else {
				findVisible2D(tile.children[0], zoom, level + 1, viewRect, visibleTiles);
				findVisible2D(tile.children[1], zoom, level + 1, viewRect, visibleTiles);
				findVisible2D(tile.children[2], zoom, level + 1, viewRect, visibleTiles);
				findVisible2D(tile.children[3], zoom, level + 1, viewRect, visibleTiles);
			}

		}

		function distanceToZoom(distance) {
			var zoom = MAX_ZOOM;

			while (distance > 123) {
				distance = distance / 2;
				zoom = zoom - 1;
			}

			return zoom;
		}

		function distanceToTile(tile) {
			if (tile == null) {
				console.log("Tile plane null left=%s,top=%s width=%s,height=%s, depth=%s ", tile.left, tile.top, tile.width, tile.height, tile.depth);
				return 1_000_000;
			}

			var pos = new THREE.Vector3(tile.centerX, tile.centerY, PLANE_Z);
			if (tile.plane != null) {
				pos = tile.plane.position;
			}

			// var distanceToVec = new THREE.Vector3(controls.target.x * 0.5, controls.target.y * 0.5, controls.target.z * 0.5);
			// distanceToVec.add(pos).divideScalar(1.5);

			//return camera.position.distanceTo(distanceToVec);
			return camera.position.distanceTo(pos);
		}

		function castToPoint(x, y, xp, yp) {
			var intersects = cast(x, y);

			if (intersects.length == 0) {
				return new THREE.Vector3(xp, yp, 0);
			}

			const intersect = intersects[0];
			return intersects[0].point;
		}

		function toNormalized(x, y) {
			return new THREE.Vector2(
				(x / window.innerWidth) * 2 - 1,
				- (y / window.innerHeight) * 2 + 1
			);
		}

		function cast(x, y) {
			const point = toNormalized(x, y);
			raycaster.setFromCamera(point, camera);

			var objects = [];
			objects.push(oldWater);
			var intersects = raycaster.intersectObjects(objects, false);

			return intersects;
		}

		function newTilePlane(tile) {
			const nTiles = zoomToNTiles(tile.zoom);

			const gridPlaneGeometry = new THREE.PlaneGeometry(SCENE_WIDTH / nTiles, SCENE_HEIGHT / nTiles, 255, 255);
			//const gridPlaneGeometry = tileGeometries.get(tile.zoom);
			const planeGrid = new THREE.Mesh(gridPlaneGeometry, buildCustomMaterial(tile.uOffset, tile.vOffset, tile.zoom));

			new THREE.TextureLoader().load('images/demTiles13/' + tile.zoom + '/' + tile.uOffset + '/' + tile.vOffset + '.png',
				function (bTexture) {
					new THREE.TextureLoader().load('images/demTiles13/' + tile.zoom + '/' + (tile.uOffset - 1) + '/' + tile.vOffset + '.png',
						function (lTexture) {
							new THREE.TextureLoader().load('images/demTiles13/' + tile.zoom + '/' + tile.uOffset + '/' + (tile.vOffset + 1) + '.png',
								function (tTexture) {
									doMap(tile, planeGrid, gridPlaneGeometry, bTexture, lTexture, tTexture);
								}
								, undefined,
								function (terr) {
									doMap(tile, planeGrid, gridPlaneGeometry, bTexture, lTexture, null);
								}
							);
						},
						undefined,
						function (lerr) {
							doMap(tile, planeGrid, gridPlaneGeometry, bTexture, null, null);
						}
					);

				}
			);

			//const planeGrid = new THREE.Mesh(gridPlaneGeometry, new THREE.MeshBasicMaterial({ color: ZOOM_COLOR_MAP[tile.zoom], side: THREE.DoubleSide }));

			//planeGrid.rotation.x = -Math.PI / 2;

			planeGrid.position.x = tile.centerX;
			planeGrid.position.y = tile.centerY;
			planeGrid.position.z = PLANE_Z;

			planeGrid.visible = false;

			// console.log("New plane added to %o for tile %o", planeGrid.position, tile);

			const wirePlane = new THREE.Mesh(tileWireGeometries.get(tile.zoom), new THREE.MeshBasicMaterial({ color: ZOOM_COLOR_MAP[tile.zoom], wireframe: true }));
			//wirePlane.position.z = 60;
			planeGrid.add(wirePlane);

			return planeGrid;
		}

		function zoomToNTiles(zoom) {
			return 2 ** (zoom);
		}

		function doMap(tile, planeGrid, gridPlaneGeometry, bTexture, lTexture, tTexture) {

			// let pos = gridPlaneGeometry.getAttribute("position");
			const pos = gridPlaneGeometry.attributes.position;

			var hVerts = gridPlaneGeometry.parameters.heightSegments + 1;
			var wVerts = gridPlaneGeometry.parameters.widthSegments + 1;
			var index = 0;


			const canvas = document.createElement('canvas');
			canvas.width = bTexture.image.width;
			canvas.height = bTexture.image.height;

			//console.log("image %s %s - plane %s %s", canvas.width, canvas.height, wVerts, hVerts)

			const context = canvas.getContext('2d');
			context.drawImage(bTexture.image, 0, 0);
			var data = context.getImageData(0, 0, canvas.width, canvas.height);


			for (let j = 0; j < hVerts; j++) {
				for (let i = 0; i < wVerts; i++) {
					//+0 is x, +1 is y.
					// pa[3*(j*wVerts+i)+0] = 5000;
					// pa[3*(j*wVerts+i)+1] = -3000;
					// pa[3*(j*wVerts+i)+2] = 200000;

					pos.setZ(index, data.data[index * 4]);
					index++;
				}
			}

			if (tTexture != null) {
				context.drawImage(tTexture.image, 0, 0);
				data = context.getImageData(0, 0, canvas.width, canvas.height);

				index = 0;
				var offset = hVerts * wVerts - 256;
				for (let j = 0; j < hVerts; j++) {
					pos.setZ(index, data.data[offset * 4]);
					index++;
					offset++;
				}
			}

			if (lTexture != null) {
				context.drawImage(lTexture.image, 0, 0);
				data = context.getImageData(0, 0, canvas.width, canvas.height);

				index = 0;
				offset = 0;
				for (let j = 0; j < wVerts; j++) {
					pos.setZ(index, data.data[(index + 255) * 4]);
					index += 256;
				}
			}

			//for ( let i = 0, l = hVerts*wVerts; i < l; i ++ ) {
			//	pos.setZ(index++,  1000);
			//}

			pos.needsUpdate = true;
			//const bpbox = new THREE.Box3().copy(tile.box);
			gridPlaneGeometry.computeBoundingBox();


			tile.box.copy(gridPlaneGeometry.boundingBox);//.applyMatrix4( planeGrid.matrixWorld );

			//tile.box.min.z -= 50;
			//tile.box.max.z += 50;

			//const bpgbox = new THREE.Box3().copy(gridPlaneGeometry.boundingBox);
			//bpgbox.applyMatrix4(planeGrid.matrixWorld);

			// console.log("pbox %o nbox %o box %o", bpbox, tile.box, bpgbox);
			// gridPlaneGeometry.computeVertexNormals();

			forceRenderMap();
		}

		function onDocumentMouseDown(event) {
			// the following line would stop any other event handler from firing
			// (such as the mouse's TrackballControls)
			// event.preventDefault();

			//console.log("Click.");

			// update the mouse variable
			const mousex = (event.clientX / window.innerWidth) * 2 - 1;
			const mousey = - (event.clientY / window.innerHeight) * 2 + 1;

			// find intersections

			// create a Ray with origin at the mouse position
			//   and direction into the scene (camera direction)
			var vector = new THREE.Vector3(mousex, mousey, 1);
			vector.unproject(camera);
			var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

			// create an array containing all objects in the scene with which the ray intersects
			const visiblePlanes = visibleTiles.filter(t => t.plane != null).map(t => t.plane);
			var intersects = ray.intersectObjects(visiblePlanes);

			// if there is one (or more) intersections
			if (intersects.length > 0) {
				// console.log("Hit @ " + toString(intersects[0].point));
				// change the color of the closest face.
				// intersects[0].face.color.setRGB(0.8 * Math.random() + 0.2, 0, 0);
				// intersects[0].object.geometry.colorsNeedUpdate = true;
				for (var tile of visibleTiles) {
					if (tile.plane == intersects[0].object) {
						tile.showBorder = true;
						tile.renderMode = null;
						selectedTile = tile;
						renderModeChanged();
						console.log("Tile intersected %s %s zoom %s", tile.uOffset, tile.vOffset, tile.zoom);
					}
				}
			}

		}

	</script>

</body>

</html>